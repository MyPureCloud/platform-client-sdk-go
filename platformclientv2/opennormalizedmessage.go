package platformclientv2
import (
	"github.com/leekchan/timeutil"
	"encoding/json"
	"strconv"
	"strings"
)

// Opennormalizedmessage - Open Messaging rich media message structure
type Opennormalizedmessage struct { 
	// Id - Unique ID of the message. This ID is generated by Messaging Platform. Message receipts will have the same ID as the message they reference, as such should only be set when sending a message receipt.
	Id *string `json:"id,omitempty"`


	// Channel - Channel-specific information that describes the message and the message channel/provider.
	Channel *Openmessagingchannel `json:"channel,omitempty"`


	// VarType - Message type.
	VarType *string `json:"type,omitempty"`


	// Text - Message text.
	Text *string `json:"text,omitempty"`


	// Content - List of content elements.
	Content *[]Openmessagecontent `json:"content,omitempty"`


	// Events - List of event elements.
	Events *[]Openmessageevent `json:"events,omitempty"`


	// Status - Message receipt status, only used with type Receipt.
	Status *string `json:"status,omitempty"`


	// Reasons - List of reasons for a message receipt that indicates the message has failed. Only used with Failed status.
	Reasons *[]Reason `json:"reasons,omitempty"`


	// IsFinalReceipt - Indicates if this is the last message receipt for this message, or if another message receipt can be expected.
	IsFinalReceipt *bool `json:"isFinalReceipt,omitempty"`


	// Direction - The direction of the message.
	Direction *string `json:"direction,omitempty"`


	// Metadata - Additional metadata about this message.
	Metadata *map[string]string `json:"metadata,omitempty"`

}

func (o *Opennormalizedmessage) MarshalJSON() ([]byte, error) {
	// Redundant initialization to avoid unused import errors for models with no Time values
	_  = timeutil.Timedelta{}
	type Alias Opennormalizedmessage
	
	return json.Marshal(&struct { 
		Id *string `json:"id,omitempty"`
		
		Channel *Openmessagingchannel `json:"channel,omitempty"`
		
		VarType *string `json:"type,omitempty"`
		
		Text *string `json:"text,omitempty"`
		
		Content *[]Openmessagecontent `json:"content,omitempty"`
		
		Events *[]Openmessageevent `json:"events,omitempty"`
		
		Status *string `json:"status,omitempty"`
		
		Reasons *[]Reason `json:"reasons,omitempty"`
		
		IsFinalReceipt *bool `json:"isFinalReceipt,omitempty"`
		
		Direction *string `json:"direction,omitempty"`
		
		Metadata *map[string]string `json:"metadata,omitempty"`
		*Alias
	}{ 
		Id: o.Id,
		
		Channel: o.Channel,
		
		VarType: o.VarType,
		
		Text: o.Text,
		
		Content: o.Content,
		
		Events: o.Events,
		
		Status: o.Status,
		
		Reasons: o.Reasons,
		
		IsFinalReceipt: o.IsFinalReceipt,
		
		Direction: o.Direction,
		
		Metadata: o.Metadata,
		Alias:    (*Alias)(o),
	})
}

func (o *Opennormalizedmessage) UnmarshalJSON(b []byte) error {
	var OpennormalizedmessageMap map[string]interface{}
	err := json.Unmarshal(b, &OpennormalizedmessageMap)
	if err != nil {
		return err
	}
	
	if Id, ok := OpennormalizedmessageMap["id"].(string); ok {
		o.Id = &Id
	}
    
	if Channel, ok := OpennormalizedmessageMap["channel"].(map[string]interface{}); ok {
		ChannelString, _ := json.Marshal(Channel)
		json.Unmarshal(ChannelString, &o.Channel)
	}
	
	if VarType, ok := OpennormalizedmessageMap["type"].(string); ok {
		o.VarType = &VarType
	}
    
	if Text, ok := OpennormalizedmessageMap["text"].(string); ok {
		o.Text = &Text
	}
    
	if Content, ok := OpennormalizedmessageMap["content"].([]interface{}); ok {
		ContentString, _ := json.Marshal(Content)
		json.Unmarshal(ContentString, &o.Content)
	}
	
	if Events, ok := OpennormalizedmessageMap["events"].([]interface{}); ok {
		EventsString, _ := json.Marshal(Events)
		json.Unmarshal(EventsString, &o.Events)
	}
	
	if Status, ok := OpennormalizedmessageMap["status"].(string); ok {
		o.Status = &Status
	}
    
	if Reasons, ok := OpennormalizedmessageMap["reasons"].([]interface{}); ok {
		ReasonsString, _ := json.Marshal(Reasons)
		json.Unmarshal(ReasonsString, &o.Reasons)
	}
	
	if IsFinalReceipt, ok := OpennormalizedmessageMap["isFinalReceipt"].(bool); ok {
		o.IsFinalReceipt = &IsFinalReceipt
	}
    
	if Direction, ok := OpennormalizedmessageMap["direction"].(string); ok {
		o.Direction = &Direction
	}
    
	if Metadata, ok := OpennormalizedmessageMap["metadata"].(map[string]interface{}); ok {
		MetadataString, _ := json.Marshal(Metadata)
		json.Unmarshal(MetadataString, &o.Metadata)
	}
	

	return nil
}

// String returns a JSON representation of the model
func (o *Opennormalizedmessage) String() string {
	j, _ := json.Marshal(o)
	str, _ := strconv.Unquote(strings.Replace(strconv.Quote(string(j)), `\\u`, `\u`, -1))

	return str
}
